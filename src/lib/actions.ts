'use server';

import { z } from 'zod';
import { analyzeDocumentSignatures } from '@/ai/flows/analyze-document-signatures';
import { extractHtmlFromDocument } from '@/ai/flows/extract-html-from-document';
import { generateSignatureAnalysisReport } from '@/ai/flows/generate-signature-analysis-report';
import * as mockDb from './mockData';
import type { Document, Proposal } from '@/types';

// Schema for creating a proposal
const CreateProposalSchema = z.object({
  name: z.string().min(3, { message: "Proposal name must be at least 3 characters." }),
});

export async function createProposalAction(formData: FormData) {
  const validatedFields = CreateProposalSchema.safeParse({
    name: formData.get('name'),
  });

  if (!validatedFields.success) {
    return {
      error: validatedFields.error.flatten().fieldErrors,
    };
  }
  try {
    const newProposal = await mockDb.createProposal(validatedFields.data.name);
    return { proposal: newProposal };
  } catch (error) {
    return { error: "Failed to create proposal." };
  }
}

export async function addDocumentToProposalAction(proposalId: string, file: File): Promise<{ document?: Document; error?: string }> {
  if (!proposalId) return { error: "Proposal ID is required." };
  if (!file) return { error: "File is required." };

  try {
    const newDocument = await mockDb.addDocumentToProposal(proposalId, file);
    if (!newDocument) return { error: "Failed to add document to proposal." };
    return { document: newDocument };
  } catch (error) {
    console.error("addDocumentToProposalAction error:", error);
    return { error: "An unexpected error occurred while adding the document." };
  }
}


export async function startSignatureAnalysisAction(proposalId: string): Promise<{ status?: string; summary?: string; error?: string }> {
  if (!proposalId) return { error: "Proposal ID is required." };

  const proposal = await mockDb.getProposalById(proposalId);
  if (!proposal) return { error: "Proposal not found." };

  proposal.signatureAnalysisStatus = 'In Progress';
  await mockDb.updateProposal(proposal);
  
  // Simulate AI call
  try {
    const result = await analyzeDocumentSignatures({ proposalId });
    
    // Simulate delay & update proposal
    await new Promise(resolve => setTimeout(resolve, 3000)); 
    
    proposal.signatureAnalysisStatus = 'Completed';
    proposal.signatureAnalysisSummary = result.reportSummary || "Analysis complete. Report generated.";
    // In a real scenario, the report HTML might be generated by another flow or stored
    const reportResult = await generateSignatureAnalysisReport({ proposalId, documentIds: proposal.documents.map(d => d.id) });
    proposal.signatureAnalysisReportHtml = reportResult.reportHtml;

    await mockDb.updateProposal(proposal);

    return { status: proposal.signatureAnalysisStatus, summary: proposal.signatureAnalysisSummary };
  } catch (e) {
    proposal.signatureAnalysisStatus = 'Failed';
    await mockDb.updateProposal(proposal);
    return { error: "Signature analysis failed." };
  }
}

export async function extractHtmlAction(proposalId: string, documentId: string, pageNumber: number): Promise<{ html?: string; error?: string }> {
  if (!proposalId || !documentId || pageNumber === undefined) return { error: "Missing parameters." };
  
  const document = await mockDb.getDocumentById(proposalId, documentId);
  if (!document) return { error: "Document not found." };

  // Mock data URI for the GenAI flow
  const mockDocumentPageDataUri = `data:image/png;base64,mock_image_data_for_page_${pageNumber}`;

  try {
    const result = await extractHtmlFromDocument({ documentPageDataUri: mockDocumentPageDataUri });
    // Store this HTML (mocked)
    await mockDb.setDocumentExtractedHtml(proposalId, documentId, pageNumber, result.html);
    return { html: result.html };
  } catch (e) {
    console.error("extractHtmlAction error:", e);
    return { error: "Failed to extract HTML." };
  }
}

export async function getSignatureImageUrlAction(proposalId: string, signatureInstanceId: string): Promise<{ imageUrl?: string; error?: string }> {
  // Mock implementation
  // In a real app, this would fetch from a service like S3 based on Textract coordinates
  return { imageUrl: `https://placehold.co/150x50.png?text=Sig-${signatureInstanceId.slice(0,4)}` };
}

export async function getDocumentPagePdfUrlAction(proposalId: string, documentId: string, pageNumber: number): Promise<{ url?: string; error?: string }> {
  // Mock implementation
  return { url: `https://placehold.co/800x1100.png?text=Doc:${documentId.slice(0,3)}-Page:${pageNumber}` };
}

export async function getDocumentPageHtmlAction(proposalId: string, documentId: string, pageNumber: number): Promise<{ html?: string; error?: string }> {
  const doc = await mockDb.getDocumentById(proposalId, documentId);
  if (doc && doc.extractedHtml && doc.extractedHtml[pageNumber]) {
    return { html: doc.extractedHtml[pageNumber] };
  }
  // Fallback if not extracted yet or for testing
  return { html: `<p>HTML for page ${pageNumber} of document ${documentId}. This content is AI-generated or retrieved from storage.</p><button>Sample Button</button>` };
}


export async function getSignatureAnalysisReportAction(proposalId: string): Promise<{ reportHtml?: string; error?: string }> {
  const proposal = await mockDb.getProposalById(proposalId);
  if (!proposal) return { error: "Proposal not found." };
  if (proposal.signatureAnalysisStatus !== 'Completed') return { error: "Analysis not yet complete."};
  
  if (proposal.signatureAnalysisReportHtml) {
    return { reportHtml: proposal.signatureAnalysisReportHtml };
  } else {
    // Fallback if not generated or for testing
    return { reportHtml: `<h1>Signature Analysis Report</h1><p>Proposal ID: ${proposalId}</p><p>No detailed report data available in mock.</p>` };
  }
}
